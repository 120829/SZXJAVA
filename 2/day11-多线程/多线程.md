## 一、多线程

**线程其实是程序中的一条执行路径。**

### 1、多线程的创建方式

#### 1.1 继承Thread类

```java
1.定义一个子类继承Thread类，并重写run方法
2.创建Thread的子类对象
3.调用start方法启动线程（启动线程后，会自动执行run方法中的代码）
```

```java
public class MyThread extends Thread{
    // 2、必须重写Thread类的run方法
    @Override
    public void run() {
        // 描述线程的执行任务。
        for (int i = 1; i <= 5; i++) {
            System.out.println("子线程MyThread输出：" + i);
        }
    }
}

public class ThreadTest1 {
    // main方法是由一条默认的主线程负责执行。
    public static void main(String[] args) {
        // 3、创建MyThread线程类的对象代表一个线程
        Thread t = new MyThread();
        // 4、启动线程（自动执行run方法的）
        t.start(); 

        for (int i = 1; i <= 5; i++) {
            System.out.println("主线程main输出：" + i);
        }
    }
}
```

**注意一点**：不能直接去调用run方法，如果直接调用run方法就不认为是一条线程启动了，而是把Thread当做一个普通对象，此时run方法中的执行的代码会成为主线程的一部分。此时执行结果是这样的。

#### 1.2 实现Runnable接口

```java
1.先写一个Runnable接口的实现类，重写run方法(这里面就是线程要执行的代码)
2.再创建一个Runnable实现类的对象
3.创建一个Thread对象，把Runnable实现类的对象传递给Thread
4.调用Thread对象的start()方法启动线程（启动后会自动执行Runnable里面的run方法）
```

```java
/**
 * 1、定义一个任务类，实现Runnable接口
 */
public class MyRunnable implements Runnable{
    // 2、重写runnable的run方法
    @Override
    public void run() {
        // 线程要执行的任务。
        for (int i = 1; i <= 5; i++) {
            System.out.println("子线程输出 ===》" + i);
        }
    }
}

public class ThreadTest2 {
    public static void main(String[] args) {
        // 3、创建任务对象。
        Runnable target = new MyRunnable();
        // 4、把任务对象交给一个线程对象处理。
        //  public Thread(Runnable target)
        new Thread(target).start();

        for (int i = 1; i <= 5; i++) {
            System.out.println("主线程main输出 ===》" + i);
        }
    }
}
```

#### 1.3 实现Callable接口

- **前两种方式线程结束后并不会返回数据，而第三种可以返回数据。**

```java
1.先定义一个Callable接口的实现类，重写call方法
2.创建Callable实现类的对象
3.创建FutureTask类的对象，将Callable对象传递给FutureTask
4.创建Thread对象，将Future对象传递给Thread
5.调用Thread的start()方法启动线程(启动后会自动执行call方法)等call()方法执行完之后，会自动将返回值结果封装到FutrueTask对象中
6.调用FutrueTask对的get()方法获取返回结果
```

```java
/**
 * 1、让这个类实现Callable接口
 */
public class MyCallable implements Callable<String> {
    private int n;
    public MyCallable(int n) {
        this.n = n;
    }

    // 2、重写call方法
    @Override
    public String call() throws Exception {
        // 描述线程的任务，返回线程执行返回后的结果。
        // 需求：求1-n的和返回。
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            sum += i;
        }
        return "线程求出了1-" + n + "的和是：" + sum;
    }
}

public class ThreadTest3 {
    public static void main(String[] args) throws Exception {
        // 3、创建一个Callable的对象
        Callable<String> call = new MyCallable(100);
        // 4、把Callable的对象封装成一个FutureTask对象（任务对象）
        // 未来任务对象的作用？
        // 1、是一个任务对象，实现了Runnable对象.
        // 2、可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果。
        FutureTask<String> f1  = new FutureTask<>(call);
        // 5、把任务对象交给一个Thread对象
        new Thread(f1).start();

        Callable<String> call2 = new MyCallable(200);
        FutureTask<String> f2  = new FutureTask<>(call2);
        new Thread(f2).start();

        // 6、获取线程执行完毕后返回的结果。
        // 注意：如果执行到这儿，假如上面的线程还没有执行完毕
        // 这里的代码会暂停，等待上面线程执行完毕后才会获取结果。
        String rs = f1.get();
        System.out.println(rs);

        String rs2 = f2.get();
        System.out.println(rs2);
    }
}
```



### 2、多线程的常用方法

#### 2.1 构造方法

| Thread构造器                                | 说明                                   |
| :------------------------------------------ | -------------------------------------- |
| public Thread(String name)                  | 可以为当前线程指定名称                 |
| public Thread(Runnable target)              | 封装Runnable对象为线程对象             |
| public Thread(Runnable target, String name) | 封装Runnable对象为线程对象，指定线程名 |

#### 2.2 其他常用方法

| Thread常用方法                       | 说明                              |
| ------------------------------------ | --------------------------------- |
| public void run()                    | 线程的任务方法                    |
| public void start()                  | 启动线程                          |
| public String getName()              | 获取当前线程名，默认为Thread-索引 |
| public void setName(String name)     | 设置线程名称                      |
| public static Thread currentThread() | 获取当前线程对象                  |
| public static void sleep(long time)  | 线程休眠指定时间                  |
| public final void join()             | 让调用当前方法的线程优先执行完    |



### 3、线程安全问题

**线程安全问题指的是，多个线程同时操作同一个共享资源的时候，可能会出现业务安全问题。**

为了解决前面的线程安全问题，我们可以使用线程同步思想。同步最常见的方案就是加锁，**意思是每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动释放锁，然后其他线程才能再加锁进来。**

```java
1.同步代码块
2.同步方法
3.Lock锁
```

#### 3.1 同步代码块

它的作用就是把访问共享数据的代码锁起来，以此保证线程安全。

```java
//锁对象：必须是一个唯一的对象（同一个地址）
synchronized(锁对象){
    //...访问共享数据的代码...
}
```

```java
// 小明 小红线程同时过来的
public void drawMoney(double money) {
    // 先搞清楚是谁来取钱？
    String name = Thread.currentThread().getName();
    // 1、判断余额是否足够
    // this正好代表共享资源！
    synchronized (this) {
        if(this.money >= money){
            System.out.println(name + "来取钱" + money + "成功！");
            this.money -= money;
            System.out.println(name + "来取钱后，余额剩余：" + this.money);
        }else {
            System.out.println(name + "来取钱：余额不足~");
        }
    }
}
```

```java
1.建议把共享资源作为锁对象, 不要将随便无关的对象当做锁对象
2.对于实例方法，建议使用this作为锁对象
3.对于静态方法，建议把类的字节码(类名.class)当做锁对象
```

#### 3.2 同步方法

**同步方法，就是把整个方法给锁住，一个线程调用这个方法，另一个线程调用的时候就执行不了，只有等上一个线程调用结束，下一个线程调用才能继续执行。**

```java
// 同步方法
public synchronized void drawMoney(double money) {
    // 先搞清楚是谁来取钱？
    String name = Thread.currentThread().getName();
    // 1、判断余额是否足够
    if(this.money >= money){
        System.out.println(name + "来取钱" + money + "成功！");
        this.money -= money;
        System.out.println(name + "来取钱后，余额剩余：" + this.money);
    }else {
        System.out.println(name + "来取钱：余额不足~");
    }
}
```

```java
同步方法也是有锁对象，只不过这个锁对象没有显示的写出来而已。
	1.对于实例方法，锁对象其实是this（也就是方法的调用者）
	2.对于静态方法，锁对象时类的字节码对象（类名.class）
```

**同步代码块和同步方法有什么区别？**

```java
1.不存在哪个好与不好，只是一个锁住的范围大，一个范围小
2.同步方法是将方法中所有的代码锁住
3.同步代码块是将方法中的部分代码锁住
```

#### 3.3 Lock锁

Lock锁是JDK5版本专门提供的一种锁对象，通过这个锁对象的方法来达到加锁，和释放锁的目的，使用起来更加灵活。格式如下：

```java
1.首先在成员变量位置，需要创建一个Lock接口的实现类对象（这个对象就是锁对象）
	private final Lock lk = new ReentrantLock();
2.在需要上锁的地方加入下面的代码
	 lk.lock(); // 加锁
	 //...中间是被锁住的代码...
	 lk.unlock(); // 解锁
```

```java
// 创建了一个锁对象
private final Lock lk = new ReentrantLock();

public void drawMoney(double money) {
        // 先搞清楚是谁来取钱？
        String name = Thread.currentThread().getName();
        try {
            lk.lock(); // 加锁
            // 1、判断余额是否足够
            if(this.money >= money){
                System.out.println(name + "来取钱" + money + "成功！");
                this.money -= money;
                System.out.println(name + "来取钱后，余额剩余：" + this.money);
            }else {
                System.out.println(name + "来取钱：余额不足~");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lk.unlock(); // 解锁
        }
    }
}
```

### 4、线程通信

**当多个线程共同操作共享资源时，线程间通过某种方式互相告知自己的状态，以相互协调，避免无效的资源挣抢。这就叫线程通信。**

**线程通信的常见模式：是生产者与消费者模型**

- 生产者线程负责生成数据
- 消费者线程负责消费生产者生成的数据
- 注意：生产者生产完数据后应该让自己等待，通知其他消费者消费；消费者消费完数据之后应该让自己等待，同时通知生产者生成。

```java
public class Desk {
    private List<String> list = new ArrayList<>();

    // 放1个包子的方法
    // 厨师1 厨师2 厨师3
    public synchronized void put() {
        try {
            String name = Thread.currentThread().getName();
            // 判断是否有包子。
            if(list.size() == 0){
                list.add(name + "做的肉包子");
                System.out.println(name + "做了一个肉包子~~");
                Thread.sleep(2000);

                // 唤醒别人, 等待自己
                this.notifyAll();
                this.wait();
            }else {
                // 有包子了，不做了。
                // 唤醒别人, 等待自己
                this.notifyAll();
                this.wait();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // 吃货1 吃货2
    public synchronized void get() {
        try {
            String name = Thread.currentThread().getName();
            if(list.size() == 1){
                // 有包子，吃了
                System.out.println(name  + "吃了：" + list.get(0));
                list.clear();
                Thread.sleep(1000);
                this.notifyAll();
                this.wait();
            }else {
                // 没有包子
                this.notifyAll();
                this.wait();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadTest {
    public static void main(String[] args) {
        //   需求：3个生产者线程，负责生产包子，每个线程每次只能生产1个包子放在桌子上
        //      2个消费者线程负责吃包子，每人每次只能从桌子上拿1个包子吃。
        Desk desk  = new Desk();

        // 创建3个生产者线程（3个厨师）
        new Thread(() -> {
            while (true) {
                desk.put();
            }
        }, "厨师1").start();

        new Thread(() -> {
            while (true) {
                desk.put();
            }
        }, "厨师2").start();

        new Thread(() -> {
            while (true) {
                desk.put();
            }
        }, "厨师3").start();

        // 创建2个消费者线程（2个吃货）
        new Thread(() -> {
            while (true) {
                desk.get();
            }
        }, "吃货1").start();

        new Thread(() -> {
            while (true) {
                desk.get();
            }
        }, "吃货2").start();
    }
}
```

### 5、线程池

**线程池就是一个可以复用线程的技术**。

```java
假设：用户每次发起一个请求给后台，后台就创建一个新的线程来处理，下次新的任务过来肯定也会创建新的线程，如果用户量非常大，创建的线程也讲越来越多。然而，创建线程是开销很大的，并且请求过多时，会严重影响系统性能。
```

线程池内部会有一个容器，存储几个核心线程，假设有3个核心线程，这3个核心线程可以处理3个任务。假设第1个线程的任务执行完了，那么第1个线程就空闲下来了，有新的任务时，空闲下来的第1个线程可以去执行其他任务。依此内推，这3个线程可以不断的复用，也可以执行很多个任务。

#### 5.1 创建线程池 （ThreadPoolExecutor 类）

```java
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)
```

- corePoolSize：核心线程数量
- maximumPoolSize：线程池最大线程数
- keepAliveTime：指定临时线程存活时间
- unit：keepAliveTime对应的时间的单位
- workQueue：线程池的任务队列
- threadFactory：线程工厂，负责创建新线程
- handler：指定线程池任务拒绝策略（线程都在忙，任务队列满的，新任务来了如何处理）

```java
ExecutorService pool = new ThreadPoolExecutor(
    3,	//核心线程数有3个
    5,  //最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2
    8,	//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。
    TimeUnit.SECONDS,//时间单位（秒）
    new ArrayBlockingQueue<>(4), //任务阻塞队列，没有来得及执行的任务在，任务队列中等待
    Executors.defaultThreadFactory(), //用于创建线程的工厂对象
    new ThreadPoolExecutor.CallerRunsPolicy() //拒绝策略
);
```

关于线程池，我们需要注意下面的两个问题

- 临时线程什么时候创建？

  ```java
  新任务提交时，发现核心线程都在忙、任务队列满了、并且还可以创建临时线程，此时会创建临时线程。
  ```

- 什么时候开始拒绝新的任务？

  ```java
  核心线程和临时线程都在忙、任务队列也满了、新任务过来时才会开始拒绝任务。
  ```

#### 5.2 线程池执行Runnable任务

| 方法名称                           | 说明                                                       |
| ---------------------------------- | ---------------------------------------------------------- |
| void execute(Runnable command)     | 执行Runnable任务                                           |
| Future<T> submit(Callable<T> task) | 执行Callable任务，返回未来任务对象，用于获取线程返回的结果 |
| void shutdown()                    | 等全部任务执行完毕后，再关闭线程池                         |
| List<Runnable> shutdownNow()       | 立刻关闭线程池，停止在执行的任务，并返回队列中未执行的任务 |

```java
public class MyRunnable implements Runnable{
    @Override
    public void run() {
        // 任务是干啥的？
        System.out.println(Thread.currentThread().getName() + " ==> 输出666~~");
        //为了模拟线程一直在执行，这里睡久一点
        try {
            Thread.sleep(Integer.MAX_VALUE);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

下面是执行Runnable任务的代码，注意阅读注释，对照着前面的7个参数理解。

```java
ExecutorService pool = new ThreadPoolExecutor(
    3,	//核心线程数有3个
    5,  //最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2
    8,	//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。
    TimeUnit.SECONDS,//时间单位（秒）
    new ArrayBlockingQueue<>(4), //任务阻塞队列，没有来得及执行的任务在，任务队列中等待
    Executors.defaultThreadFactory(), //用于创建线程的工厂对象
    new ThreadPoolExecutor.CallerRunsPolicy() //拒绝策略
);

Runnable target = new MyRunnable();
pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！
pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！
pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！
//下面4个任务在任务队列里排队
pool.execute(target);
pool.execute(target);
pool.execute(target);
pool.execute(target);

//下面2个任务，会被临时线程的创建时机了
pool.execute(target);
pool.execute(target);
// 到了新任务的拒绝时机了！
pool.execute(target);
```

#### 5.3 线程池执行Callable任务

**callable任务相对于Runnable任务来说，就是多了一个返回值。**



```java
public class MyCallable implements Callable<String> {
    private int n;
    public MyCallable(int n) {
        this.n = n;
    }

    // 2、重写call方法
    @Override
    public String call() throws Exception {
        // 描述线程的任务，返回线程执行返回后的结果。
        // 需求：求1-n的和返回。
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            sum += i;
        }
        return Thread.currentThread().getName() + "求出了1-" + n + "的和是：" + sum;
    }
}
```

再准备一个测试类，在测试类中创建线程池，并执行callable任务。

```java
public class ThreadPoolTest2 {
    public static void main(String[] args) throws Exception {
        // 1、通过ThreadPoolExecutor创建一个线程池对象。
        ExecutorService pool = new ThreadPoolExecutor(
            3,
            5,
            8,
            TimeUnit.SECONDS, 
            new ArrayBlockingQueue<>(4),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.CallerRunsPolicy());

        // 2、使用线程处理Callable任务。
        Future<String> f1 = pool.submit(new MyCallable(100));
        Future<String> f2 = pool.submit(new MyCallable(200));
        Future<String> f3 = pool.submit(new MyCallable(300));
        Future<String> f4 = pool.submit(new MyCallable(400));

        // 3、执行完Callable任务后，需要获取返回结果。
        System.out.println(f1.get());
        System.out.println(f2.get());
        System.out.println(f3.get());
        System.out.println(f4.get());
    }
}
```



### 6、补充

#### 6.1 并发与并行

- 正常运行的程序（软件）就是一个独立的进程
- 线程是属于进程，一个进程中包含多个线程
- 进程中的线程其实并发和并行同时存在

- **什么是并发？**

```java
进程中的线程由CPU负责调度执行，但是CPU同时处理线程的数量是有限的，为了保证全部线程都能执行到，CPU采用轮询机制为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。（简单记：并发就是多条线程交替执行）
```

- **什么是并行？**

```java
并行指的是，多个线程同时被CPU调度执行。
```



#### 6.2 线程的生命周期

```java
NEW: 新建状态，线程还没有启动
RUNNABLE: 可以运行状态，线程调用了start()方法后处于这个状态
BLOCKED: 锁阻塞状态，没有获取到锁处于这个状态
WAITING: 无限等待状态，线程执行时被调用了wait方法处于这个状态
TIMED_WAITING: 计时等待状态，线程执行时被调用了sleep(毫秒)或者wait(毫秒)方法处于这个状态
TERMINATED: 终止状态, 线程执行完毕或者遇到异常时，处于这个状态。
```

```mermaid
stateDiagram-v2
    [*] --> NEW : 创建线程
    NEW --> RUNNABLE : 调用 start()
    RUNNABLE --> TERMINATED : 执行完毕 或 抛出异常
    RUNNABLE --> BLOCKED : 等待锁
    RUNNABLE --> WAITING : join()/wait() 等待
    RUNNABLE --> TIMED_WAITING : sleep()/wait(timeout) 等待

    BLOCKED --> RUNNABLE : 获得锁
    WAITING --> RUNNABLE : 被唤醒（notify/join 完成）
    TIMED_WAITING --> RUNNABLE : 超时/被唤醒

    TERMINATED --> [*]